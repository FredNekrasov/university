//
// Created by fred on 26.11.2024.
//
#include <stdio.h>
#include <stdlib.h>
// Даны два массива.
// Даны два массива. Подсчитать произведение положительных элементов того массива, в котором окажется минимальный элемент.
// Число элементов массива не более 10. Формат элемента ццц. Вид распечатки результатов разработать самостоятельно.
int AlKatePW4() {
    srand(21u);
    int n = 0;// число элементов массива, пока что 0
    printf("input n:");// выводим сообщение "input n:"
    /*
     * %d - формат целого числа, не дробного. Для дробных чисел используется %f
     * &переменная - переменная, куда будет записан результат
     */
    scanf_s("%d", &n);// вводим число элементов массива
    if (n > 10) return printf("error: n > 10");// если число элементов массива больше 10, то выводим ошибку и завершаем программу
    int array1[n], array2[n];// объявляем статические массивы размером n
    /*
     * Цикл для заполнения массивов случайными числами
     * i - индекс элемента массива/позиция элемента
     * rand() - случайное число
     * int i = 0 - начальное значение (в языке C/С++ индексы начинаются с 0)
     * Например:
     * при n = 10
     * i = 0 - элемент массива с индексом 0/первый элемент массива,
     * i = 1 - элемент массива с индексом 1/второй элемент массива,
     * i = 2 - элемент массива с индексом 2/третий элемент массива,
     * ...,
     * i = 9 - элемент массива с индексом 9/десятый элемент массива.
     * Цикл начинается с 0, пока значение i меньше n. Как только i станет больше или равно n, цикл завершается
     * i++ / i += 1 / i = i + 1 - прибавляем 1 к значению i.
     * Получается, что шаблон цикла for следующий:
     * for (начальное значение; условие завершения цикла/условие выполнения цикла; шаг цикла)
     * Шаг цикла - значение, которое будет прибавляться к значению i при каждом проходе цикла, чтобы завершить цикл.
     * В данном случае шаг равен 1, то есть i будет увеличиваться на 1 каждым проходом цикла.
     * Например:
     * int i = 0;
     * while (i < n) {
     *     // тело цикла
     *     i++;
     * }
     * В примере выше цикл for преобразовали в while, чтобы было более понятно, что делает цикл.
     * Создали переменную i и задали ему начальное значение 0
     * Пока i < n выполняем тело цикла, после увеличиваем значение i на 1
     */
    for (int i = 0; i < n; i++) {
        /*
         * Случайное число делим на 10 и получаем остаток. Получается, что числа в основном будут от 0 до 9. % - деление с остатком
         * Например:
         * 1) 10 разделить на 10 будет 1 без остатка, значит мы получим 0.
         * 2) 19 разделить на 10 будет 1 с остатком 9, значит мы получим 9.
         * Таким вот образом в массиве будут находиться числа в диапазоне от 0 до 9.
         */
        array1[i] = rand() % 10;
        array2[i] = rand() % 10;
    }
    printf("array1: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", array1[i]);
    }
    printf("\narray2: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", array2[i]);
    }
    /*
     * Поиск минимальных элементов массивов
     * minArr1 - минимальный элемент первого массива
     * minArr2 - минимальный элемент второго массива
     * Сразу присваиваем им значение первого элемента соответствующего массива, чтобы пропустить 1 проход цикла.
     */
    int minArr1 = array1[0], minArr2 = array2[0];
    for (int i = 1; i < n; i++) {
        /*
         * Если элемент массива в позиции i меньше minArr1, то присваиваем minArr1 значение элемента массива в позиции i, потому что он является минимальным в результате сравнения.
         * Если элемент массива в позиции i больше minArr1, то мы ничего не делаем
         * Это повторяется для minArr2
         * Таким образом находим минимальные элементы массивов
         */
        if (array1[i] < minArr1) minArr1 = array1[i];
        if (array2[i] < minArr2) minArr2 = array2[i];
    }
    printf("\nminArr1: %d", minArr1);
    printf("\nminArr2: %d", minArr2);
    int multiplication = 1;
    /*
     * Если minArr1 меньше minArr2, то мы умножаем положительные элементы массива array1.
     * В ином случае мы умножаем положительные элементы массива array2.
     */
    if (minArr1 < minArr2) {
        for (int i = 0; i < n; i++) {
            if (array1[i] > 0) multiplication *= array1[i];// Умножаем только положительные значения
        }
    } else {
        for (int i = 0; i < n; i++) {
            if (array2[i] > 0) multiplication *= array2[i];// Умножаем только положительные значения, то есть значения больше 0
        }
    }
    printf("\nmultiplication: %d", multiplication);
    return 0;
}